# Lab8

## [练习0] 填写已有实验

> 已完成

## [练习1] 完成读文件操作的实现

[练习1.1] 请在实验报告中给出设计实现”UNIX的PIPE机制“的概要设方案，鼓励给出详细设计方案

> 概要设计方案

> - 结构：文件、写位置、读位置、锁。
> - 文件，可用于不同进程的读写。
> - 写位置：写入时更新。
> - 读位置：读取时更新。
> - 锁：若读位置等于写位置时读取，那么等待这个锁。写后，如果有进程在等待，唤醒之。读后，如果读位置小于写位置，且有进程在等待，唤醒之。

## [练习2] 完成基于文件系统的执行程序机制的实现

[练习2.1] 请在实验报告中给出设计实现基于”UNIX的硬链接和软链接机制“的概要设方案，鼓励给出详细设计方案

> 概要设计方案

> - 硬链接：接口`int vfs_link(char *old_path, char *new_path);`。创建new_file的文件，把inode指向old_path的inode，引用计数加1。读写操作的时候，会自动操作用一个inode，无需修改；删除操作时，引用计数减1，如果减至0，删除这个文件。

> - 软链接：创建软链接时分配创建一个新的文件（这时创建了一个新的inode），并把old_path的内容存放到文件的内容中去，给该文件保存在磁盘上时disk_inode类型为SFS_TYPE_LINK。对于类型为SFS_TYPE_LINK的disk_inode，执行读写操作时，先读出old_path，然后对old_path执行读写操作；unlink时与删除一个普通文件相同。

## 与参考答案的区别：

> Exercise 1：我写的程序代码复用率比较高，更符合面向对象的思想。避免同样的代码多次出现，降低debug难度和留下隐患的可能。参考答案非常冗长，有35行，主要内容是反反复复地判断几个边界问题。其实做好设计和规划后，这些冗余判断都是可以避免的。我的代码只有8行（每行至多一句执行语句），每次读写前，提前算清楚块编号、偏移量、长度，就可以最大限度做到代码复用。

> Exercise 2：参考答案第743行`uargv[i] = strcpy((char *)(stacktop + argv_size ), kargv[i]);`是错误的，有溢出问题，会被用于缓冲区溢出攻击，造成**本地特权提升**、**拒绝服务攻击**等严重后果，在测例中没有体现出来是因为实验给的测例很不充分。正确做法是像我的代码里一样`uint32_t arglen = strnlen(kargv[i], EXEC_MAX_ARG_LEN); memcpy(uarg_buf, kargv[i], arglen); uarg_buf[arglen] = '\0';`，strnlen保证获取的长度不超过EXEC_MAX_ARG_LEN，memcpy保证不会造成缓冲区溢出，补0保证strnlen == EXEC_MAX_ARG_LEN时不会造成字符串非封闭。

## 重要的知识点

> - 文件系统
> - VFS接口
> - 文件读写
> - 内存映射
> - 加载用户程序
> - 栈帧
> - 命令行参数

> 没有涉及的训练：与磁盘输入输出相关的底层支持的实现。
